<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å¦å…‹å¤§æˆ˜ - qingyu</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            touch-action: none;
        }
        
        html, body {
            background: #1a1a2e;
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            color: #fff;
        }
        
        .game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            width: 100%;
            height: 100%;
            padding: 10px;
        }
        
        .game-header {
            text-align: center;
            margin-bottom: 5px;
        }
        
        h1 {
            font-size: 1.5rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 5px;
        }
        
        .info {
            display: flex;
            justify-content: center;
            gap: 15px;
            font-size: 0.85rem;
            flex-wrap: wrap;
        }
        
        .info span { font-weight: bold; }
        .score { color: #ffd700; }
        .combo { color: #ff6b6b; }
        .lives { color: #ff6b6b; }
        .base-hp { color: #4ecdc4; }
        
        .game-area {
            position: relative;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
        }
        
        .version {
            position: absolute;
            bottom: 5px;
            right: 10px;
            font-size: 0.7rem;
            color: rgba(136, 146, 176, 0.5);
            pointer-events: none;
            z-index: 10;
        }
        
        #gameCanvas {
            background: #0a0a0a;
            border: 2px solid #667eea;
            border-radius: 4px;
            display: block;
            max-width: 100%;
            max-height: 100%;
        }
        
        /* è¦†ç›–å±‚ */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            border-radius: 4px;
        }
        
        .overlay h2 {
            font-size: 2rem;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .menu-btn {
            padding: 12px 40px;
            margin: 8px;
            font-size: 1rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 8px;
            color: #fff;
            cursor: pointer;
            min-width: 180px;
        }
        
        .menu-btn:active {
            transform: scale(0.95);
        }
        
        .menu-btn.secondary {
            background: rgba(102, 126, 234, 0.3);
            border: 2px solid #667eea;
        }
        
        .high-score {
            margin: 15px 0;
            padding: 10px 25px;
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid #ffd700;
            border-radius: 8px;
            text-align: center;
        }
        
        .high-score h3 { color: #ffd700; margin-bottom: 3px; font-size: 0.9rem; }
        .high-score p { font-size: 1.2rem; font-weight: bold; }
        
        .hidden { display: none !important; }
        
        /* ç§»åŠ¨ç«¯è™šæ‹ŸæŒ‰é”® */
        .mobile-controls {
            display: none;
            width: 100%;
            padding: 15px 30px 30px;
            justify-content: space-between;
            align-items: flex-end;
        }
        
        .mobile-controls.active {
            display: flex;
        }
        
        .d-pad {
            position: relative;
            width: 180px;
            height: 180px;
        }
        
        .d-btn {
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(102, 126, 234, 0.5);
            border: 3px solid rgba(102, 126, 234, 0.9);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            color: #fff;
            cursor: pointer;
        }
        
        .d-btn:active, .d-btn.pressed {
            background: rgba(102, 126, 234, 0.9);
        }
        
        .d-btn.up { top: 0; left: 60px; }
        .d-btn.down { bottom: 0; left: 60px; }
        .d-btn.left { top: 60px; left: 0; }
        .d-btn.right { top: 60px; right: 0; }
        
        .fire-btn {
            width: 110px;
            height: 110px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 107, 107, 0.8) 0%, rgba(255, 107, 107, 0.5) 100%);
            border: 4px solid rgba(255, 107, 107, 0.9);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            color: #fff;
            cursor: pointer;
            box-shadow: 0 0 30px rgba(255, 107, 107, 0.6);
        }
        
        .fire-btn:active, .fire-btn.pressed {
            transform: scale(0.92);
            background: radial-gradient(circle, rgba(255, 107, 107, 1) 0%, rgba(255, 107, 107, 0.7) 100%);
        }
        
        /* æ¸¸æˆç»“æŸé¢æ¿ */
        .game-over-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 25px 30px;
            border-radius: 10px;
            border: 2px solid #667eea;
            text-align: center;
            z-index: 200;
            min-width: 280px;
        }
        
        .game-over-panel h2 {
            font-size: 1.5rem;
            margin-bottom: 15px;
        }
        
        .game-over-panel.win h2 { color: #4ecdc4; }
        .game-over-panel.lose h2 { color: #ff6b6b; }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin: 15px 0;
        }
        
        .stat-item {
            background: rgba(255,255,255,0.1);
            padding: 8px;
            border-radius: 5px;
            font-size: 0.85rem;
        }
        
        /* æ¨ªå±æç¤º */
        .rotate-hint {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a2e;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            text-align: center;
            padding: 20px;
        }
        
        .rotate-hint.show {
            display: flex;
        }
        
        .rotate-hint .phone-icon {
            font-size: 80px;
            margin-bottom: 20px;
            animation: rotatePhone 2s infinite;
        }
        
        @keyframes rotatePhone {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(90deg); }
        }
        
        .rotate-hint h2 {
            font-size: 1.5rem;
            margin-bottom: 10px;
            color: #667eea;
        }
        
        .rotate-hint p {
            color: #8892b0;
            font-size: 1rem;
        }
        
        /* æ¨ªå±æ—¶éšè—æç¤º */
        @media (orientation: landscape) and (max-width: 900px) {
            .rotate-hint {
                display: none !important;
            }
        }
        
        /* ç«–å±æ—¶æ˜¾ç¤ºæç¤º */
        @media (orientation: portrait) and (max-width: 600px) {
            .game-wrapper {
                display: none;
            }
            .rotate-hint.show {
                display: flex;
            }
        }
        @media (min-width: 769px) {
            .game-wrapper {
                flex-direction: row;
                gap: 20px;
                padding: 20px;
            }
            
            h1 { font-size: 2rem; }
            
            .info { font-size: 1rem; gap: 20px; }
            
            .legend {
                display: block;
                background: rgba(0, 0, 0, 0.5);
                padding: 15px;
                border-radius: 8px;
                border: 1px solid #667eea;
                min-width: 180px;
            }
            
            .legend h3 { margin-bottom: 10px; color: #667eea; }
            
            .legend-item {
                display: flex;
                align-items: center;
                margin: 8px 0;
                font-size: 0.85rem;
            }
            
            .legend-icon {
                width: 20px;
                height: 20px;
                margin-right: 8px;
                border-radius: 3px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 12px;
            }
        }
        
        @media (max-width: 768px) {
            .legend { display: none; }
            
            #gameCanvas {
                width: 100% !important;
                height: auto !important;
                max-height: calc(100vh - 200px);
            }
        }
    </style>
</head>
<body>
    <!-- æ¨ªå±æç¤º -->
    <div class="rotate-hint" id="rotateHint">
        <div class="phone-icon">ğŸ“±</div>
        <h2>è¯·æ—‹è½¬æ‰‹æœº</h2>
        <p>æ¨ªå±ä½“éªŒæ›´ä½³</p>
    </div>
    
    <div class="game-wrapper">
        <div class="game-main">
            <div class="game-header">
                <h1>ğŸ® å¦å…‹å¤§æˆ˜</h1>
                <div class="info">
                    <span>å¾—åˆ†: <span class="score" id="score">0</span></span>
                    <span>è¿å‡»: <span class="combo" id="combo">0</span></span>
                    <span>ç”Ÿå‘½: <span class="lives" id="lives">â¤ï¸â¤ï¸â¤ï¸</span></span>
                    <span>åŸºåœ°: <span class="base-hp" id="baseHp">ğŸ ğŸ ğŸ </span></span>
                </div>
            </div>
            
            <div class="game-area" id="gameArea">
                <canvas id="gameCanvas" width="600" height="400"></canvas>
                <div class="version">v3.3</div>
                
                <!-- ä¸»èœå• -->
                <div class="overlay" id="mainMenu">
                    <h2>ğŸ”¥ å¦å…‹å¤§æˆ˜</h2>
                    <div class="high-score">
                        <h3>ğŸ† æœ€é«˜åˆ†</h3>
                        <p id="highScoreDisplay">0</p>
                    </div>
                    <button class="menu-btn" onclick="startGame()">â–¶ï¸ å¼€å§‹æ¸¸æˆ</button>
                    <button class="menu-btn secondary" onclick="toggleMobileMode()" id="mobileBtn">ğŸ“± æ‰‹æœºæ¨¡å¼</button>
                    <button class="menu-btn secondary" onclick="showHelp()">â“ æ“ä½œè¯´æ˜</button>
                </div>
                
                <!-- æš‚åœèœå• -->
                <div class="overlay hidden" id="pauseMenu">
                    <h2>â¸ï¸ å·²æš‚åœ</h2>
                    <button class="menu-btn" onclick="resumeGame()">â–¶ï¸ ç»§ç»­æ¸¸æˆ</button>
                    <button class="menu-btn secondary" onclick="backToMenu()">ğŸ  è¿”å›èœå•</button>
                </div>
                
                <!-- æ¸¸æˆç»“æŸ -->
                <div class="game-over-panel hidden" id="gameOver">
                    <h2 id="gameOverTitle">GAME OVER</h2>
                    <div class="stats-grid">
                        <div class="stat-item"><strong>å¾—åˆ†</strong><p id="finalScore">0</p></div>
                        <div class="stat-item"><strong>è¿å‡»</strong><p id="maxCombo">0</p></div>
                        <div class="stat-item"><strong>å‡»æ€</strong><p id="enemiesKilled">0</p></div>
                        <div class="stat-item"><strong>å…³å¡</strong><p id="finalLevel">1</p></div>
                    </div>
                    <p id="gameOverReason" style="color: #8892b0; margin-bottom: 15px;"></p>
                    <button class="menu-btn" onclick="restartGame()">ğŸ”„ å†æ¥ä¸€å±€</button>
                    <button class="menu-btn secondary" onclick="backToMenu()">ğŸ  è¿”å›èœå•</button>
                </div>
            </div>
            
            <!-- è™šæ‹ŸæŒ‰é”® -->
            <div class="mobile-controls" id="mobileControls">
                <div class="d-pad">
                    <div class="d-btn up" data-key="w">â–²</div>
                    <div class="d-btn down" data-key="s">â–¼</div>
                    <div class="d-btn left" data-key="a">â—€</div>
                    <div class="d-btn right" data-key="d">â–¶</div>
                </div>
                <div class="fire-btn" data-key="j">ğŸ’¥</div>
            </div>
        </div>
        
        <!-- æ¡Œé¢ç«¯å›¾é‰´ -->
        <div class="legend" id="legendPanel">
            <h3>ğŸ“‹ å›¾é‰´</h3>
            <div class="legend-item"><div class="legend-icon" style="background: #228b22;">ğŸŒ¿</div><span>è‰åœ° - éšèº«</span></div>
            <div class="legend-item"><div class="legend-icon" style="background: #8b4513;">ğŸ§±</div><span>ç –å¢™ - å¯ç ´å</span></div>
            <div class="legend-item"><div class="legend-icon" style="background: #4682b4;">ğŸ›¡ï¸</div><span>é’¢å¢™ - æ— æ•Œ</span></div>
            <div class="legend-item"><div class="legend-icon" style="background: linear-gradient(45deg, #ffd700, #ffed4e);">â­</div><span>æ˜Ÿæ˜Ÿ - ç«åŠ›+</span></div>
            <div class="legend-item"><div class="legend-icon" style="background: linear-gradient(45deg, #ff6b6b, #ff8e8e);">â¤ï¸</div><span>ç”Ÿå‘½ - +1</span></div>
            <div class="legend-item"><div class="legend-icon" style="background: linear-gradient(45deg, #4ecdc4, #7fdbda);">ğŸ›¡ï¸</div><span>æŠ¤ç›¾ - 5ç§’</span></div>
            <div class="legend-item"><div class="legend-icon" style="background: linear-gradient(45deg, #ff4757, #ff6348);">ğŸ’£</div><span>ç‚¸å¼¹ - æ¸…å±</span></div>
            <div class="legend-item"><div class="legend-icon" style="background: linear-gradient(45deg, #a8e6cf, #dcedc1);">ğŸ </div><span>åŸºåœ° - å®ˆæŠ¤!</span></div>
        </div>
    </div>

    <script>
        // ============ æ¸¸æˆé…ç½® ============
        const CANVAS_WIDTH = 600;
        const CANVAS_HEIGHT = 400;
        const TILE_SIZE = 40;
        const TANK_SIZE = 30;
        const BULLET_SIZE = 6;
        const PLAYER_SPEED = 3;
        const ENEMY_SPEED_BASE = 1.5;
        const BULLET_SPEED = 8;
        
        const Direction = { UP: 0, RIGHT: 1, DOWN: 2, LEFT: 3 };
        
        const CellType = {
            EMPTY: 0, BRICK: 1, GRASS: 2, STEEL: 3,
            PLAYER_SPAWN: 4, ENEMY_SPAWN: 5, BASE: 9
        };
        
        const PowerUpType = { STAR: 'star', LIFE: 'life', SHIELD: 'shield', BOMB: 'bomb' };
        
        const EnemyType = {
            NORMAL: { color: '#ff6b6b', hp: 1, speed: 1, score: 100 },
            FAST: { color: '#ffa502', hp: 1, speed: 1.8, score: 150 },
            HEAVY: { color: '#8e44ad', hp: 3, speed: 0.8, score: 300 },
            ELITE: { color: '#e74c3c', hp: 2, speed: 1.3, score: 250 }
        };
        
        const MAPS = [
            [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,4,0,0,2,2,0,0,2,2,0,0,0,5,1],
                [1,0,1,0,2,0,1,1,0,2,0,1,0,0,1],
                [1,0,1,0,0,0,0,0,0,0,0,1,0,0,1],
                [1,2,2,0,1,1,0,0,1,1,0,2,2,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,0,1,0,2,0,1,9,1,0,2,0,1,0,1],
                [1,0,1,0,2,0,1,3,1,0,2,0,1,0,1],
                [1,5,0,0,0,0,0,0,0,0,0,0,0,5,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
            ],
            [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,4,0,3,2,2,0,0,2,2,3,0,0,5,1],
                [1,0,3,0,2,0,3,3,0,2,0,3,0,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,2,2,0,1,1,0,0,1,1,0,2,2,0,1],
                [1,3,0,0,0,0,0,0,0,0,0,0,0,3,1],
                [1,0,1,0,2,0,1,9,1,0,2,0,1,0,1],
                [1,0,3,0,2,0,1,3,1,0,2,0,3,0,1],
                [1,5,0,0,0,0,0,0,0,0,0,0,0,5,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
            ],
            [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,4,0,0,0,0,0,0,0,0,0,0,0,5,1],
                [1,0,3,2,3,0,0,0,0,0,3,2,3,0,1],
                [1,0,2,0,0,0,1,1,1,0,0,0,2,0,1],
                [1,0,3,0,0,0,0,9,0,0,0,0,3,0,1],
                [1,0,2,0,0,0,1,3,1,0,0,0,2,0,1],
                [1,0,3,2,3,0,0,0,0,0,3,2,3,0,1],
                [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
                [1,5,0,0,0,0,0,0,0,0,0,0,0,5,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
            ],
            [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,4,0,0,0,0,0,5,0,0,0,0,0,5,1],
                [1,0,3,3,0,0,0,0,0,0,0,3,3,0,1],
                [1,0,3,2,2,0,0,0,0,0,2,2,3,0,1],
                [1,0,0,2,9,3,0,0,0,3,9,2,0,0,1],
                [1,0,0,0,3,3,0,0,0,3,3,0,0,0,1],
                [1,0,3,2,2,0,0,0,0,0,2,2,3,0,1],
                [1,0,3,3,0,0,0,0,0,0,0,3,3,0,1],
                [1,5,0,0,0,0,0,5,0,0,0,0,0,5,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
            ],
            [
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
                [1,4,3,0,0,0,0,0,0,0,0,0,0,3,1],
                [1,3,2,3,0,3,3,0,0,3,3,0,3,2,1],
                [1,0,3,0,0,0,0,0,0,0,0,0,0,3,1],
                [1,0,0,0,3,3,0,9,0,3,3,0,0,0,1],
                [1,0,3,0,3,3,0,3,0,3,3,0,3,0,1],
                [1,3,2,3,0,0,0,0,0,0,0,3,2,3,1],
                [1,0,3,0,0,0,0,0,0,0,0,0,3,0,1],
                [1,3,0,0,0,3,3,5,3,3,0,0,0,3,1],
                [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
            ]
        ];
        
        // ============ æ¸¸æˆçŠ¶æ€ ============
        let canvas, ctx;
        let gameState = 'MENU'; // MENU, PLAYING, PAUSED, GAMEOVER
        let map = [];
        let powerUps = [];
        let score = 0, lives = 3, level = 1, baseHp = 3;
        let keys = {};
        let grassAlpha = 0.6;
        let highScore = 0;
        let mobileMode = false;
        
        let stats = { enemiesKilled: 0, maxCombo: 0, currentCombo: 0, comboTimer: 0 };
        
        let player = { x: 0, y: 0, dir: Direction.UP, color: '#4ecdc4', lastShot: 0, shotInterval: 300, powerLevel: 1, shieldTime: 0, inGrass: false };
        let enemies = [], bullets = [], explosions = [], floatingTexts = [];
        let basePos = { x: 0, y: 0 };
        let animationId = null;
        
        // ============ åˆå§‹åŒ– ============
        function init() {
            // è·å–ç”»å¸ƒ
            canvas = document.getElementById('gameCanvas');
            if(!canvas) {
                console.error('Canvas not found!');
                return;
            }
            
            ctx = canvas.getContext('2d');
            if(!ctx) {
                console.error('Context not available!');
                return;
            }
            
            // è®¾ç½®å®é™…ç”»å¸ƒå°ºå¯¸
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;
            
            // åŠ è½½æœ€é«˜åˆ†
            try {
                highScore = parseInt(localStorage.getItem('tankHighScore') || '0');
            } catch(e) {
                highScore = 0;
            }
            document.getElementById('highScoreDisplay').textContent = highScore;
            
            // æ£€æµ‹ç§»åŠ¨è®¾å¤‡
            const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
            const isSmallScreen = window.innerWidth <= 768;
            mobileMode = isTouchDevice || isSmallScreen;
            
            if(mobileMode) {
                document.getElementById('mobileControls').classList.add('active');
                document.getElementById('mobileBtn').textContent = 'ğŸ“± æ‰‹æœºæ¨¡å¼: å¼€';
            }
            
            // ç»‘å®šè™šæ‹ŸæŒ‰é”®
            setupMobileControls();
            
            // ç»‘å®šé”®ç›˜äº‹ä»¶
            setupKeyboard();
            
            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', handleResize);
            handleResize();
            
            // åˆå§‹åŒ–æ¸¸æˆæ•°æ®
            initMap();
            initPlayer();
            updateUI();
            
            // å¯åŠ¨æ¸¸æˆå¾ªç¯
            gameLoop();
            
            console.log('Game initialized. Mobile mode:', mobileMode);
        }
        
        function handleResize() {
            const container = document.getElementById('gameArea');
            const maxWidth = container.clientWidth - 10;
            const maxHeight = window.innerHeight - (mobileMode ? 280 : 150);
            
            const scale = Math.min(maxWidth / CANVAS_WIDTH, maxHeight / CANVAS_HEIGHT, 1);
            
            canvas.style.width = Math.floor(CANVAS_WIDTH * scale) + 'px';
            canvas.style.height = Math.floor(CANVAS_HEIGHT * scale) + 'px';
        }
        
        function setupMobileControls() {
            const buttons = document.querySelectorAll('.d-btn, .fire-btn');
            
            buttons.forEach(btn => {
                const key = btn.getAttribute('data-key');
                if(!key) return;
                
                // è§¦æ‘¸äº‹ä»¶
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    keys[key] = true;
                    btn.classList.add('pressed');
                }, { passive: false });
                
                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    keys[key] = false;
                    btn.classList.remove('pressed');
                }, { passive: false });
                
                btn.addEventListener('touchcancel', (e) => {
                    keys[key] = false;
                    btn.classList.remove('pressed');
                });
                
                // é¼ æ ‡äº‹ä»¶
                btn.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    keys[key] = true;
                    btn.classList.add('pressed');
                });
                
                btn.addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    keys[key] = false;
                    btn.classList.remove('pressed');
                });
                
                btn.addEventListener('mouseleave', () => {
                    keys[key] = false;
                    btn.classList.remove('pressed');
                });
            });
        }
        
        function setupKeyboard() {
            document.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                keys[key] = true;
                
                if(key === 'p') {
                    if(gameState === 'PLAYING') pauseGame();
                    else if(gameState === 'PAUSED') resumeGame();
                }
                
                if(['arrowup','arrowdown','arrowleft','arrowright',' '].includes(key)) {
                    e.preventDefault();
                }
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
            });
        }
        
        // ============ æ¸¸æˆé€»è¾‘ ============
        function initMap() {
            const mapIndex = Math.min(level - 1, MAPS.length - 1);
            map = JSON.parse(JSON.stringify(MAPS[mapIndex]));
            
            for(let row = 0; row < map.length; row++) {
                for(let col = 0; col < map[row].length; col++) {
                    if(map[row][col] === CellType.BASE) {
                        basePos = { x: col * TILE_SIZE, y: row * TILE_SIZE };
                    }
                }
            }
        }
        
        function initPlayer() {
            for(let row = 0; row < map.length; row++) {
                for(let col = 0; col < map[row].length; col++) {
                    if(map[row][col] === CellType.PLAYER_SPAWN) {
                        player.x = col * TILE_SIZE + (TILE_SIZE - TANK_SIZE) / 2;
                        player.y = row * TILE_SIZE + (TILE_SIZE - TANK_SIZE) / 2;
                        player.dir = Direction.UP;
                        player.shieldTime = 2000;
                        player.powerLevel = Math.min(player.powerLevel, 1);
                    }
                }
            }
        }
        
        function startGame() {
            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('legendPanel').classList.add('hidden');
            gameState = 'PLAYING';
            resetGame();
        }
        
        function resetGame() {
            score = 0;
            lives = 3;
            level = 1;
            baseHp = 3;
            stats = { enemiesKilled: 0, maxCombo: 0, currentCombo: 0, comboTimer: 0 };
            player.powerLevel = 1;
            enemies = [];
            bullets = [];
            explosions = [];
            powerUps = [];
            floatingTexts = [];
            
            initMap();
            initPlayer();
            updateUI();
            
            // å»¶è¿Ÿç”Ÿæˆæ•Œäºº
            setTimeout(() => spawnEnemy(), 500);
            setTimeout(() => spawnEnemy(), 1500);
        }
        
        function pauseGame() {
            if(gameState === 'PLAYING') {
                gameState = 'PAUSED';
                document.getElementById('pauseMenu').classList.remove('hidden');
            }
        }
        
        function resumeGame() {
            gameState = 'PLAYING';
            document.getElementById('pauseMenu').classList.add('hidden');
        }
        
        function backToMenu() {
            gameState = 'MENU';
            document.getElementById('pauseMenu').classList.add('hidden');
            document.getElementById('gameOver').classList.add('hidden');
            document.getElementById('mainMenu').classList.remove('hidden');
            document.getElementById('legendPanel').classList.remove('hidden');
            document.getElementById('highScoreDisplay').textContent = highScore;
        }
        
        function toggleMobileMode() {
            mobileMode = !mobileMode;
            const mobileControls = document.getElementById('mobileControls');
            const btn = document.getElementById('mobileBtn');
            
            if(mobileMode) {
                mobileControls.classList.add('active');
                btn.textContent = 'ğŸ“± æ‰‹æœºæ¨¡å¼: å¼€';
            } else {
                mobileControls.classList.remove('active');
                btn.textContent = 'ğŸ“± æ‰‹æœºæ¨¡å¼: å…³';
            }
            
            handleResize();
        }
        
        function showHelp() {
            const msg = mobileMode 
                ? 'ğŸ® æ“ä½œè¯´æ˜\n\nç§»åŠ¨: å·¦ä¸‹è§’æ–¹å‘é”®\nå°„å‡»: å³ä¸‹è§’çº¢è‰²æŒ‰é’®\næš‚åœ: ç‚¹å‡»å±å¹•å¤–åŒºåŸŸ\n\nğŸ¯ æ¶ˆç­æ•Œäººï¼Œä¿æŠ¤åŸºåœ°ï¼'
                : 'ğŸ® æ“ä½œè¯´æ˜\n\nç§»åŠ¨: WASD æˆ– æ–¹å‘é”®\nå°„å‡»: J æˆ– ç©ºæ ¼\næš‚åœ: P\n\nğŸ¯ æ¶ˆç­æ•Œäººï¼Œä¿æŠ¤åŸºåœ°ï¼';
            alert(msg);
        }
        
        function spawnEnemy() {
            if(gameState !== 'PLAYING') return;
            
            const spawnPoints = [];
            for(let row = 0; row < map.length; row++) {
                for(let col = 0; col < map[row].length; col++) {
                    if(map[row][col] === CellType.ENEMY_SPAWN) {
                        spawnPoints.push({
                            x: col * TILE_SIZE + (TILE_SIZE - TANK_SIZE) / 2,
                            y: row * TILE_SIZE + (TILE_SIZE - TANK_SIZE) / 2
                        });
                    }
                }
            }
            
            const maxEnemies = 3 + Math.min(level, 5);
            if(spawnPoints.length > 0 && enemies.length < maxEnemies) {
                const spawn = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
                
                // æ£€æŸ¥æ˜¯å¦å¯ä»¥ç”Ÿæˆ
                let canSpawn = true;
                for(let e of enemies) {
                    if(Math.abs(e.x - spawn.x) < TANK_SIZE && Math.abs(e.y - spawn.y) < TANK_SIZE) {
                        canSpawn = false;
                        break;
                    }
                }
                
                if(canSpawn) {
                    let enemyType = EnemyType.NORMAL;
                    const rand = Math.random();
                    
                    if(level >= 5 && rand < 0.15) enemyType = EnemyType.ELITE;
                    else if(level >= 4 && rand < 0.3) enemyType = EnemyType.HEAVY;
                    else if(level >= 2 && rand < 0.4) enemyType = EnemyType.FAST;
                    
                    enemies.push({
                        x: spawn.x, y: spawn.y,
                        dir: Direction.DOWN,
                        type: enemyType,
                        color: enemyType.color,
                        hp: enemyType.hp,
                        maxHp: enemyType.hp,
                        speed: enemyType.speed * ENEMY_SPEED_BASE,
                        score: enemyType.score,
                        lastShot: 0,
                        shotInterval: 1500 - level * 100,
                        lastMove: 0,
                        moveInterval: 1000
                    });
                }
            }
        }
        
        function spawnPowerUp() {
            if(Math.random() > 0.25 || powerUps.length >= 2) return;
            
            const emptySpots = [];
            for(let row = 1; row < map.length - 1; row++) {
                for(let col = 1; col < map[row].length - 1; col++) {
                    if(map[row][col] === CellType.EMPTY) {
                        emptySpots.push({ x: col * TILE_SIZE, y: row * TILE_SIZE });
                    }
                }
            }
            
            if(emptySpots.length === 0) return;
            
            const spot = emptySpots[Math.floor(Math.random() * emptySpots.length)];
            const types = [PowerUpType.STAR, PowerUpType.LIFE, PowerUpType.SHIELD, PowerUpType.BOMB];
            const type = types[Math.floor(Math.random() * types.length)];
            
            powerUps.push({
                x: spot.x + TILE_SIZE / 2 - 15,
                y: spot.y + TILE_SIZE / 2 - 15,
                type: type,
                spawnTime: Date.now()
            });
        }
        
        function collectPowerUp(powerUp) {
            switch(powerUp.type) {
                case PowerUpType.STAR:
                    player.powerLevel = Math.min(player.powerLevel + 1, 3);
                    score += 50;
                    showFloatingText(player.x, player.y - 20, 'ç«åŠ›+' + player.powerLevel, '#ffd700');
                    break;
                case PowerUpType.LIFE:
                    lives = Math.min(lives + 1, 5);
                    showFloatingText(player.x, player.y - 20, 'ç”Ÿå‘½+1', '#ff6b6b');
                    break;
                case PowerUpType.SHIELD:
                    player.shieldTime = 5000;
                    showFloatingText(player.x, player.y - 20, 'æŠ¤ç›¾!', '#4ecdc4');
                    break;
                case PowerUpType.BOMB:
                    enemies.forEach(e => {
                        createExplosion(e.x + TANK_SIZE/2, e.y + TANK_SIZE/2, e.color, 15);
                        score += 100;
                        stats.enemiesKilled++;
                    });
                    enemies = [];
                    showFloatingText(player.x, player.y - 20, 'BOOM!', '#ff4757');
                    break;
            }
            updateUI();
        }
        
        function showFloatingText(x, y, text, color) {
            floatingTexts.push({ x, y, text, color, life: 1, vy: -1.5 });
        }
        
        // ============ ç¢°æ’æ£€æµ‹ ============
        function checkRectCollision(r1, r2) {
            return r1.x < r2.x + r2.width && r1.x + r1.width > r2.x &&
                   r1.y < r2.y + r2.height && r1.y + r1.height > r2.y;
        }
        
        function checkWallCollision(x, y) {
            const tankRect = { x, y, width: TANK_SIZE, height: TANK_SIZE };
            
            for(let row = 0; row < map.length; row++) {
                for(let col = 0; col < map[row].length; col++) {
                    const cell = map[row][col];
                    if(cell === CellType.BRICK || cell === CellType.STEEL) {
                        const wallRect = {
                            x: col * TILE_SIZE, y: row * TILE_SIZE,
                            width: TILE_SIZE, height: TILE_SIZE
                        };
                        if(checkRectCollision(tankRect, wallRect)) return true;
                    }
                }
            }
            return false;
        }
        
        function checkInGrass(x, y) {
            const centerX = x + TANK_SIZE / 2;
            const centerY = y + TANK_SIZE / 2;
            const col = Math.floor(centerX / TILE_SIZE);
            const row = Math.floor(centerY / TILE_SIZE);
            
            if(row >= 0 && row < map.length && col >= 0 && col < map[0].length) {
                return map[row][col] === CellType.GRASS;
            }
            return false;
        }
        
        function shoot(tank, isPlayer) {
            const now = Date.now();
            if(now - tank.lastShot < tank.shotInterval) return;
            tank.lastShot = now;
            
            let bx = tank.x + TANK_SIZE / 2 - BULLET_SIZE / 2;
            let by = tank.y + TANK_SIZE / 2 - BULLET_SIZE / 2;
            
            switch(tank.dir) {
                case Direction.UP: by -= TANK_SIZE / 2; break;
                case Direction.DOWN: by += TANK_SIZE / 2; break;
                case Direction.LEFT: bx -= TANK_SIZE / 2; break;
                case Direction.RIGHT: bx += TANK_SIZE / 2; break;
            }
            
            const bulletCount = isPlayer ? Math.min(tank.powerLevel, 2) : 1;
            
            for(let i = 0; i < bulletCount; i++) {
                let offsetX = 0, offsetY = 0;
                if(bulletCount === 2) {
                    if(tank.dir === Direction.UP || tank.dir === Direction.DOWN) {
                        offsetX = (i === 0 ? -8 : 8);
                    } else {
                        offsetY = (i === 0 ? -8 : 8);
                    }
                }
                
                bullets.push({
                    x: bx + offsetX, y: by + offsetY,
                    dir: tank.dir,
                    isPlayer: isPlayer,
                    color: isPlayer ? '#ffd700' : '#ff4757',
                    power: isPlayer ? tank.powerLevel : 1
                });
            }
        }
        
        // ============ æ›´æ–°é€»è¾‘ ============
        function updatePlayer() {
            if(gameState !== 'PLAYING') return;
            
            let newX = player.x;
            let newY = player.y;
            let moved = false;
            
            if(keys['w'] || keys['arrowup']) {
                newY -= PLAYER_SPEED;
                player.dir = Direction.UP;
                moved = true;
            } else if(keys['s'] || keys['arrowdown']) {
                newY += PLAYER_SPEED;
                player.dir = Direction.DOWN;
                moved = true;
            } else if(keys['a'] || keys['arrowleft']) {
                newX -= PLAYER_SPEED;
                player.dir = Direction.LEFT;
                moved = true;
            } else if(keys['d'] || keys['arrowright']) {
                newX += PLAYER_SPEED;
                player.dir = Direction.RIGHT;
                moved = true;
            }
            
            if(moved) {
                newX = Math.max(0, Math.min(CANVAS_WIDTH - TANK_SIZE, newX));
                newY = Math.max(0, Math.min(CANVAS_HEIGHT - TANK_SIZE, newY));
                
                if(!checkWallCollision(newX, newY)) {
                    player.x = newX;
                    player.y = newY;
                }
            }
            
            player.inGrass = checkInGrass(player.x, player.y);
            if(player.shieldTime > 0) player.shieldTime -= 16;
            
            if(keys['j'] || keys[' ']) {
                shoot(player, true);
            }
            
            // æ‹¾å–é“å…·
            for(let i = powerUps.length - 1; i >= 0; i--) {
                const p = powerUps[i];
                if(checkRectCollision(
                    { x: player.x, y: player.y, width: TANK_SIZE, height: TANK_SIZE },
                    { x: p.x, y: p.y, width: 30, height: 30 }
                )) {
                    collectPowerUp(p);
                    powerUps.splice(i, 1);
                }
            }
        }
        
        function updateEnemies() {
            if(gameState !== 'PLAYING') return;
            
            const now = Date.now();
            
            enemies.forEach(enemy => {
                if(now - enemy.lastMove > enemy.moveInterval) {
                    const dx = player.x - enemy.x;
                    const dy = player.y - enemy.y;
                    
                    if(Math.random() < 0.6) {
                        if(Math.abs(dx) > Math.abs(dy)) {
                            enemy.dir = dx > 0 ? Direction.RIGHT : Direction.LEFT;
                        } else {
                            enemy.dir = dy > 0 ? Direction.DOWN : Direction.UP;
                        }
                    } else {
                        enemy.dir = Math.floor(Math.random() * 4);
                    }
                    
                    enemy.lastMove = now;
                }
                
                let newX = enemy.x, newY = enemy.y;
                
                switch(enemy.dir) {
                    case Direction.UP: newY -= enemy.speed; break;
                    case Direction.DOWN: newY += enemy.speed; break;
                    case Direction.LEFT: newX -= enemy.speed; break;
                    case Direction.RIGHT: newX += enemy.speed; break;
                }
                
                newX = Math.max(0, Math.min(CANVAS_WIDTH - TANK_SIZE, newX));
                newY = Math.max(0, Math.min(CANVAS_HEIGHT - TANK_SIZE, newY));
                
                if(!checkWallCollision(newX, newY)) {
                    enemy.x = newX;
                    enemy.y = newY;
                } else {
                    enemy.dir = Math.floor(Math.random() * 4);
                }
                
                if(Math.random() < 0.03) shoot(enemy, false);
            });
        }
        
        function updateBullets() {
            bullets = bullets.filter(bullet => {
                switch(bullet.dir) {
                    case Direction.UP: bullet.y -= BULLET_SPEED; break;
                    case Direction.DOWN: bullet.y += BULLET_SPEED; break;
                    case Direction.LEFT: bullet.x -= BULLET_SPEED; break;
                    case Direction.RIGHT: bullet.x += BULLET_SPEED; break;
                }
                
                if(bullet.x < 0 || bullet.x > CANVAS_WIDTH || 
                   bullet.y < 0 || bullet.y > CANVAS_HEIGHT) {
                    return false;
                }
                
                const bulletRect = { x: bullet.x, y: bullet.y, width: BULLET_SIZE, height: BULLET_SIZE };
                
                // æ’å¢™æ£€æµ‹
                for(let row = 0; row < map.length; row++) {
                    for(let col = 0; col < map[row].length; col++) {
                        const cell = map[row][col];
                        if(cell === CellType.BRICK || cell === CellType.STEEL || cell === CellType.BASE) {
                            const wallRect = {
                                x: col * TILE_SIZE, y: row * TILE_SIZE,
                                width: TILE_SIZE, height: TILE_SIZE
                            };
                            
                            if(checkRectCollision(bulletRect, wallRect)) {
                                createExplosion(bullet.x, bullet.y, '#888', 5);
                                
                                if(cell === CellType.BRICK) {
                                    map[row][col] = CellType.EMPTY;
                                    score += 10;
                                }
                                
                                if(cell === CellType.BASE) {
                                    baseHp--;
                                    createExplosion(col * TILE_SIZE + TILE_SIZE/2, row * TILE_SIZE + TILE_SIZE/2, '#ff6b6b', 20);
                                    updateUI();
                                    if(baseHp <= 0) {
                                        gameOver(false, 'åŸºåœ°è¢«æ‘§æ¯ï¼');
                                    }
                                }
                                
                                updateUI();
                                return false;
                            }
                        }
                    }
                }
                
                // å‡»ä¸­æ£€æµ‹
                if(bullet.isPlayer) {
                    for(let i = enemies.length - 1; i >= 0; i--) {
                        const e = enemies[i];
                        if(checkRectCollision(bulletRect, { x: e.x, y: e.y, width: TANK_SIZE, height: TANK_SIZE })) {
                            createExplosion(e.x + TANK_SIZE/2, e.y + TANK_SIZE/2, e.color, 10);
                            e.hp--;
                            
                            if(e.hp <= 0) {
                                enemies.splice(i, 1);
                                
                                stats.currentCombo++;
                                stats.comboTimer = 2000;
                                if(stats.currentCombo > stats.maxCombo) {
                                    stats.maxCombo = stats.currentCombo;
                                }
                                
                                const comboBonus = Math.min(stats.currentCombo * 10, 100);
                                score += e.score + comboBonus;
                                
                                if(stats.currentCombo >= 3) {
                                    showFloatingText(e.x, e.y - 30, `${stats.currentCombo}è¿å‡»!`, '#ff6b6b');
                                }
                                
                                stats.enemiesKilled++;
                                if(Math.random() < 0.2) spawnPowerUp();
                            }
                            
                            updateUI();
                            return false;
                        }
                    }
                } else {
                    if(checkRectCollision(bulletRect, { x: player.x, y: player.y, width: TANK_SIZE, height: TANK_SIZE })) {
                        if(player.shieldTime <= 0) {
                            createExplosion(player.x + TANK_SIZE/2, player.y + TANK_SIZE/2, player.color, 15);
                            lives--;
                            stats.currentCombo = 0;
                            updateUI();
                            if(lives <= 0) {
                                gameOver(false, 'ç”Ÿå‘½è€—å°½ï¼');
                            } else {
                                initPlayer();
                            }
                        } else {
                            createExplosion(bullet.x, bullet.y, '#4ecdc4', 5);
                        }
                        return false;
                    }
                }
                
                return true;
            });
        }
        
        function createExplosion(x, y, color, count) {
            for(let i = 0; i < count; i++) {
                explosions.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 12,
                    vy: (Math.random() - 0.5) * 12,
                    life: 1,
                    color,
                    size: 3 + Math.random() * 4
                });
            }
        }
        
        function updateExplosions() {
            explosions = explosions.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.04;
                return p.life > 0;
            });
        }
        
        // ============ ç»˜åˆ¶ ============
        function drawTank(tank, isPlayer) {
            ctx.save();
            ctx.translate(tank.x + TANK_SIZE/2, tank.y + TANK_SIZE/2);
            
            if(tank.inGrass) ctx.globalAlpha = 0.5;
            
            if(isPlayer && player.shieldTime > 0) {
                ctx.beginPath();
                ctx.arc(0, 0, TANK_SIZE/2 + 6, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(78, 205, 196, ${0.5 + Math.sin(Date.now() / 100) * 0.3})`;
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            
            let angle = 0;
            switch(tank.dir) {
                case Direction.UP: angle = -Math.PI/2; break;
                case Direction.RIGHT: angle = 0; break;
                case Direction.DOWN: angle = Math.PI/2; break;
                case Direction.LEFT: angle = Math.PI; break;
            }
            ctx.rotate(angle);
            
            ctx.fillStyle = tank.color;
            ctx.fillRect(-TANK_SIZE/2, -TANK_SIZE/2, TANK_SIZE, TANK_SIZE);
            
            if(!isPlayer && tank.maxHp > 1) {
                ctx.restore();
                ctx.save();
                const hpPercent = tank.hp / tank.maxHp;
                ctx.fillStyle = '#333';
                ctx.fillRect(tank.x, tank.y - 8, TANK_SIZE, 4);
                ctx.fillStyle = hpPercent > 0.5 ? '#2ecc71' : '#e74c3c';
                ctx.fillRect(tank.x, tank.y - 8, TANK_SIZE * hpPercent, 4);
                ctx.restore();
                ctx.save();
                ctx.translate(tank.x + TANK_SIZE/2, tank.y + TANK_SIZE/2);
                ctx.rotate(angle);
            }
            
            ctx.fillStyle = '#333';
            ctx.fillRect(-TANK_SIZE/2 - 2, -TANK_SIZE/2 + 2, 4, TANK_SIZE - 4);
            ctx.fillRect(TANK_SIZE/2 - 2, -TANK_SIZE/2 + 2, 4, TANK_SIZE - 4);
            
            ctx.beginPath();
            ctx.arc(0, 0, TANK_SIZE/3, 0, Math.PI * 2);
            ctx.fill();
            
            if(isPlayer && tank.powerLevel > 1) {
                ctx.fillStyle = '#ffd700';
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('â˜…'.repeat(tank.powerLevel - 1), 0, 4);
            }
            
            ctx.fillStyle = '#444';
            ctx.fillRect(0, -3, TANK_SIZE/2 + 10, 6);
            
            ctx.restore();
        }
        
        function drawMap() {
            for(let row = 0; row < map.length; row++) {
                for(let col = 0; col < map[row].length; col++) {
                    const cell = map[row][col];
                    const x = col * TILE_SIZE;
                    const y = row * TILE_SIZE;
                    
                    switch(cell) {
                        case CellType.BRICK:
                            ctx.fillStyle = '#8b4513';
                            ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                            ctx.fillStyle = '#a0522d';
                            ctx.fillRect(x + 3, y + 3, TILE_SIZE - 6, TILE_SIZE - 6);
                            ctx.fillStyle = '#cd853f';
                            ctx.fillRect(x + 8, y + 8, TILE_SIZE - 16, 4);
                            ctx.fillRect(x + 8, y + 16, TILE_SIZE - 16, 4);
                            ctx.fillRect(x + 8, y + 24, TILE_SIZE - 16, 4);
                            break;
                            
                        case CellType.STEEL:
                            ctx.fillStyle = '#4682b4';
                            ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                            ctx.fillStyle = '#5f9ea0';
                            ctx.fillRect(x + 2, y + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                            ctx.strokeStyle = '#2f4f4f';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(x + 6, y + 6, TILE_SIZE - 12, TILE_SIZE - 12);
                            ctx.beginPath();
                            ctx.moveTo(x + 6, y + 6);
                            ctx.lineTo(x + TILE_SIZE - 6, y + TILE_SIZE - 6);
                            ctx.stroke();
                            break;
                            
                        case CellType.GRASS:
                            ctx.fillStyle = `rgba(34, 139, 34, ${grassAlpha})`;
                            ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                            ctx.fillStyle = `rgba(0, 100, 0, ${grassAlpha * 0.6})`;
                            for(let i = 0; i < 4; i++) {
                                ctx.fillRect(x + 5 + i * 8, y + 5 + (i % 2) * 10, 4, 15);
                            }
                            break;
                            
                        case CellType.BASE:
                            ctx.fillStyle = '#8b4513';
                            ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                            ctx.fillStyle = '#deb887';
                            ctx.fillRect(x + 4, y + 4, TILE_SIZE - 8, TILE_SIZE - 8);
                            ctx.fillStyle = '#ff6b6b';
                            ctx.beginPath();
                            ctx.moveTo(x + TILE_SIZE/2, y + 6);
                            ctx.lineTo(x + 6, y + TILE_SIZE/2);
                            ctx.lineTo(x + TILE_SIZE - 6, y + TILE_SIZE/2);
                            ctx.closePath();
                            ctx.fill();
                            ctx.fillRect(x + 10, y + TILE_SIZE/2, TILE_SIZE - 20, TILE_SIZE/2 - 8);
                            ctx.fillStyle = '#fff';
                            ctx.fillRect(x + 14, y + TILE_SIZE/2 + 4, 4, 6);
                            break;
                    }
                }
            }
        }
        
        function drawPowerUps() {
            const now = Date.now();
            
            powerUps.forEach((p, index) => {
                if(now - p.spawnTime > 10000) {
                    powerUps.splice(index, 1);
                    return;
                }
                
                if(now - p.spawnTime > 7000 && Math.floor(now / 200) % 2 === 0) return;
                
                const icons = { star: 'â­', life: 'â¤ï¸', shield: 'ğŸ›¡ï¸', bomb: 'ğŸ’£' };
                const colors = {
                    star: ['#ffd700', '#ffed4e'],
                    life: ['#ff6b6b', '#ff8e8e'],
                    shield: ['#4ecdc4', '#7fdbda'],
                    bomb: ['#ff4757', '#ff6348']
                };
                
                const gradient = ctx.createRadialGradient(
                    p.x + 15, p.y + 15, 0,
                    p.x + 15, p.y + 15, 25
                );
                gradient.addColorStop(0, colors[p.type][0]);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(p.x + 15, p.y + 15, 25, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.font = '22px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(icons[p.type], p.x + 15, p.y + 24);
            });
        }
        
        function draw() {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            // ç»˜åˆ¶ç½‘æ ¼
            ctx.strokeStyle = '#1a1a2e';
            ctx.lineWidth = 1;
            for(let i = 0; i <= CANVAS_WIDTH; i += TILE_SIZE) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, CANVAS_HEIGHT);
                ctx.stroke();
            }
            for(let i = 0; i <= CANVAS_HEIGHT; i += TILE_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(CANVAS_WIDTH, i);
                ctx.stroke();
            }
            
            drawMap();
            grassAlpha = 0.4 + Math.sin(Date.now() / 400) * 0.15;
            
            drawPowerUps();
            enemies.forEach(e => drawTank(e));
            drawTank(player, true);
            
            // ç»˜åˆ¶å­å¼¹
            bullets.forEach(b => {
                ctx.fillStyle = b.color;
                ctx.beginPath();
                ctx.arc(b.x + BULLET_SIZE/2, b.y + BULLET_SIZE/2, BULLET_SIZE/2, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = b.color + '66';
                ctx.beginPath();
                ctx.arc(b.x + BULLET_SIZE/2, b.y + BULLET_SIZE/2, BULLET_SIZE + 2, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // ç»˜åˆ¶çˆ†ç‚¸
            explosions.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;
            
            // ç»˜åˆ¶æµ®åŠ¨æ–‡å­—
            floatingTexts = floatingTexts.filter(t => {
                t.y += t.vy;
                t.life -= 0.02;
                if(t.life > 0) {
                    ctx.fillStyle = t.color;
                    ctx.globalAlpha = t.life;
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(t.text, t.x, t.y);
                    ctx.globalAlpha = 1;
                    return true;
                }
                return false;
            });
        }
        
        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            document.getElementById('lives').textContent = 'â¤ï¸'.repeat(Math.max(0, lives));
            document.getElementById('baseHp').textContent = 'ğŸ '.repeat(Math.max(0, baseHp));
            document.getElementById('combo').textContent = stats.currentCombo;
        }
        
        function gameOver(won, reason) {
            gameState = 'GAMEOVER';
            
            if(score > highScore) {
                highScore = score;
                try {
                    localStorage.setItem('tankHighScore', highScore);
                } catch(e) {}
            }
            
            const panel = document.getElementById('gameOver');
            panel.className = 'game-over-panel ' + (won ? 'win' : 'lose');
            panel.classList.remove('hidden');
            
            document.getElementById('gameOverTitle').textContent = won ? 'ğŸ‰ VICTORY!' : 'ğŸ’€ GAME OVER';
            document.getElementById('gameOverReason').textContent = reason;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('maxCombo').textContent = stats.maxCombo;
            document.getElementById('enemiesKilled').textContent = stats.enemiesKilled;
            document.getElementById('finalLevel').textContent = level;
        }
        
        function restartGame() {
            document.getElementById('gameOver').classList.add('hidden');
            gameState = 'PLAYING';
            resetGame();
        }
        
        // ============ æ¸¸æˆå¾ªç¯ ============
        function gameLoop() {
            if(gameState === 'PLAYING') {
                updatePlayer();
                updateEnemies();
                updateBullets();
                updateExplosions();
                
                if(stats.currentCombo > 0) {
                    stats.comboTimer -= 16;
                    if(stats.comboTimer <= 0) {
                        stats.currentCombo = 0;
                        updateUI();
                    }
                }
                
                if(Math.random() < 0.015 + level * 0.002) spawnEnemy();
                if(Math.random() < 0.005) spawnPowerUp();
                
                // å…³å¡æ£€æµ‹
                if(score >= level * 800 && enemies.length === 0 && level < MAPS.length) {
                    level++;
                    showFloatingText(CANVAS_WIDTH/2, CANVAS_HEIGHT/2, `ç¬¬ ${level} å…³!`, '#ffd700');
                    initMap();
                    initPlayer();
                    enemies = [];
                    bullets = [];
                } else if(level >= MAPS.length && score >= MAPS.length * 800 && enemies.length === 0) {
                    gameOver(true, 'æ­å–œé€šå…³æ‰€æœ‰å…³å¡ï¼');
                }
            }
            
            // å§‹ç»ˆç»˜åˆ¶
            draw();
            
            animationId = requestAnimationFrame(gameLoop);
        }
        
        // æ£€æµ‹å±å¹•æ–¹å‘
        function checkOrientation() {
            const rotateHint = document.getElementById('rotateHint');
            const isPortrait = window.innerHeight > window.innerWidth;
            const isMobile = window.innerWidth <= 600;
            
            if (isMobile && isPortrait) {
                rotateHint.classList.add('show');
            } else {
                rotateHint.classList.remove('show');
            }
        }
        
        window.addEventListener('resize', checkOrientation);
        window.addEventListener('orientationchange', checkOrientation);
        
        // å¯åŠ¨æ¸¸æˆ
        window.onload = function() {
            init();
            checkOrientation();
        };
        
        // é˜²æ­¢è§¦æ‘¸æ»šåŠ¨
        document.addEventListener('touchmove', function(e) {
            e.preventDefault();
        }, { passive: false });
    </script>
</body>
</html>
