<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å¦å…‹å¤§æˆ˜ - qingyu</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            touch-action: none;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        
        #gameFrame {
            position: relative;
            width: 100%;
            height: 100%;
        }
        
        /* æ¸¸æˆç”»å¸ƒ - å…¨å±è‡ªé€‚åº” */
        #gameCanvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #0a0a0a;
            border: 2px solid #444;
        }
        
        /* é¡¶éƒ¨çŠ¶æ€æ  - æ‚¬æµ® */
        #topBar {
            position: absolute;
            top: 10px;
            left: 15px;
            right: 15px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 10;
        }
        
        .stat-box {
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 12px;
            border-radius: 20px;
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .stat-box.score { color: #ffd700; }
        .stat-box.lives { color: #ff6b6b; }
        .stat-box.base { color: #4ecdc4; }
        
        /* å·¦ä¸‹è§’è™šæ‹Ÿæ‘‡æ† - ç‹è€…è£è€€é£æ ¼ */
        #leftControl {
            position: absolute;
            bottom: 40px;
            left: 40px;
            width: 180px;
            height: 180px;
            z-index: 20;
            display: none;
        }
        
        #leftControl.active {
            display: block;
        }
        
        .joystick-base {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 150px;
            height: 150px;
            background: rgba(255, 255, 255, 0.15);
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
        }
        
        .joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            background: radial-gradient(circle at 30% 30%, rgba(102, 126, 234, 0.9), rgba(70, 100, 200, 0.8));
            border: 3px solid rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.5);
            transition: none;
            pointer-events: none;
        }
        
        .joystick-knob.active {
            background: radial-gradient(circle at 30% 30%, rgba(120, 150, 255, 1), rgba(90, 120, 220, 0.9));
        }
        
        /* å³ä¸‹è§’å°„å‡»æŒ‰é’® */
        #rightControl {
            position: absolute;
            bottom: 30px;
            right: 30px;
            z-index: 20;
            display: none;
        }
        
        #rightControl.active {
            display: block;
        }
        
        .fire-btn {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(255, 100, 100, 0.9), rgba(200, 50, 50, 0.7));
            border: 3px solid rgba(255, 200, 200, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            color: #fff;
            cursor: pointer;
            box-shadow: 0 0 30px rgba(255, 100, 100, 0.4), inset 0 0 20px rgba(255, 255, 255, 0.2);
            transition: transform 0.1s;
        }
        
        .fire-btn:active, .fire-btn.pressed {
            transform: scale(0.92);
            background: radial-gradient(circle at 30% 30%, rgba(255, 120, 120, 1), rgba(220, 70, 70, 0.8));
        }
        
        /* èœå•è¦†ç›–å±‚ */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
        
        .overlay h2 {
            font-size: 2.5rem;
            margin-bottom: 30px;
            color: #fff;
            text-shadow: 0 0 20px #667eea;
        }
        
        .menu-btn {
            padding: 15px 50px;
            margin: 8px;
            font-size: 1.1rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 30px;
            color: #fff;
            cursor: pointer;
            min-width: 220px;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        .menu-btn:active {
            transform: scale(0.95);
        }
        
        .menu-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #667eea;
        }
        
        .high-score {
            margin: 20px 0;
            padding: 15px 40px;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 215, 0, 0.05));
            border: 2px solid #ffd700;
            border-radius: 15px;
            text-align: center;
        }
        
        .high-score h3 { color: #ffd700; margin-bottom: 5px; }
        .high-score p { font-size: 1.5rem; font-weight: bold; color: #fff; }
        
        /* æ¸¸æˆç»“æŸé¢æ¿ */
        .game-over-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 30, 0.98);
            padding: 30px 40px;
            border-radius: 20px;
            border: 2px solid #667eea;
            text-align: center;
            z-index: 200;
            min-width: 300px;
        }
        
        .game-over-panel h2 {
            font-size: 1.8rem;
            margin-bottom: 20px;
            color: #fff;
        }
        
        .game-over-panel.win h2 { color: #4ecdc4; text-shadow: 0 0 10px #4ecdc4; }
        .game-over-panel.lose h2 { color: #ff6b6b; text-shadow: 0 0 10px #ff6b6b; }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin: 20px 0;
        }
        
        .stat-item {
            background: rgba(255,255,255,0.05);
            padding: 12px;
            border-radius: 10px;
            color: #fff;
        }
        
        .stat-item strong { display: block; color: #8892b0; font-size: 0.85rem; margin-bottom: 3px; }
        .stat-item p { font-size: 1.2rem; font-weight: bold; }
        
        /* å›¾é‰´ - åªåœ¨èœå•æ˜¾ç¤º */
        #legendBox {
            max-width: 300px;
            margin: 15px 0;
            padding: 15px 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
        }
        
        #legendBox h3 { margin-bottom: 12px; color: #667eea; text-align: center; }
        
        .legend-row {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.8rem;
            color: #fff;
            background: rgba(0,0,0,0.3);
            padding: 5px 10px;
            border-radius: 15px;
        }
        
        .legend-icon {
            width: 18px;
            height: 18px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }
        
        /* ç‰ˆæœ¬å· */
        .version {
            position: absolute;
            bottom: 5px;
            right: 10px;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.3);
            z-index: 5;
        }
        
        .hidden { display: none !important; }
        
        /* æš‚åœæŒ‰é’® */
        #pauseBtn {
            position: absolute;
            top: 10px;
            right: 15px;
            width: 40px;
            height: 40px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: #fff;
            cursor: pointer;
            z-index: 30;
            display: none;
        }
        
        #pauseBtn.active {
            display: flex;
        }
        
        #pauseBtn:active {
            background: rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<body>
    <div id="gameFrame">
        <!-- æ¸¸æˆç”»å¸ƒ -->
        <canvas id="gameCanvas" width="600" height="400"></canvas>
        
        <!-- é¡¶éƒ¨çŠ¶æ€æ  -->
        <div id="topBar">
            <div class="stat-box score">
                <span>ğŸ’°</span><span id="scoreVal">0</span>
            </div>
            <div style="display: flex; gap: 10px;">
                <div class="stat-box lives">
                    <span>â¤ï¸</span><span id="livesVal">3</span>
                </div>
                <div class="stat-box base">
                    <span>ğŸ </span><span id="baseVal">3</span>
                </div>
            </div>
        </div>
        
        <!-- æš‚åœæŒ‰é’® -->
        <div id="pauseBtn" onclick="pauseGame()">â¸ï¸</div>
        
        <!-- å·¦ä¸‹è§’è™šæ‹Ÿæ‘‡æ† -->
        <div id="leftControl">
            <div class="joystick-base" id="joystickBase"></div>
            <div class="joystick-knob" id="joystickKnob"></div>
        </div>
        
        <!-- å³ä¸‹è§’å°„å‡» -->
        <div id="rightControl">
            <div class="fire-btn" data-key="j">ğŸ’¥</div>
        </div>
        
        <!-- ä¸»èœå• -->
        <div class="overlay" id="mainMenu">
            <h2>ğŸ”¥ å¦å…‹å¤§æˆ˜</h2>
            
            <div class="high-score">
                <h3>ğŸ† æœ€é«˜åˆ†</h3>
                <p id="highScoreDisplay">0</p>
            </div>
            
            <div id="legendBox">
                <h3>ğŸ“‹ å›¾é‰´</h3>
                <div class="legend-row">
                    <div class="legend-item"><div class="legend-icon" style="background: #228b22;">ğŸŒ¿</div><span>è‰åœ°éšèº«</span></div>
                    <div class="legend-item"><div class="legend-icon" style="background: #8b4513;">ğŸ§±</div><span>ç –å¢™å¯ç ´</span></div>
                    <div class="legend-item"><div class="legend-icon" style="background: #4682b4;">ğŸ›¡ï¸</div><span>é’¢å¢™æ— æ•Œ</span></div>
                    <div class="legend-item"><div class="legend-icon" style="background: linear-gradient(45deg, #ffd700, #ffed4e);">â­</div><span>ç«åŠ›+</span></div>
                    <div class="legend-item"><div class="legend-icon" style="background: linear-gradient(45deg, #ff6b6b, #ff8e8e);">â¤ï¸</div><span>ç”Ÿå‘½+</span></div>
                    <div class="legend-item"><div class="legend-icon" style="background: linear-gradient(45deg, #4ecdc4, #7fdbda);">ğŸ›¡ï¸</div><span>æŠ¤ç›¾</span></div>
                    <div class="legend-item"><div class="legend-icon" style="background: linear-gradient(45deg, #ff4757, #ff6348);">ğŸ’£</div><span>ç‚¸å¼¹</span></div>
                </div>
            </div>
            
            <button class="menu-btn" onclick="startGame()">â–¶ï¸ å¼€å§‹æ¸¸æˆ</button>
            <button class="menu-btn secondary" onclick="toggleMobileMode()" id="mobileBtn">ğŸ“± è§¦å±æ¨¡å¼</button>
        </div>
        
        <!-- æš‚åœèœå• -->
        <div class="overlay hidden" id="pauseMenu">
            <h2>â¸ï¸ å·²æš‚åœ</h2>
            <button class="menu-btn" onclick="resumeGame()">â–¶ï¸ ç»§ç»­</button>
            <button class="menu-btn secondary" onclick="backToMenu()">ğŸ  è¿”å›èœå•</button>
        </div>
        
        <!-- æ¸¸æˆç»“æŸ -->
        <div class="game-over-panel hidden" id="gameOver">
            <h2 id="gameOverTitle">GAME OVER</h2>
            <div class="stats-grid">
                <div class="stat-item"><strong>å¾—åˆ†</strong><p id="finalScore">0</p></div>
                <div class="stat-item"><strong>è¿å‡»</strong><p id="maxCombo">0</p></div>
                <div class="stat-item"><strong>å‡»æ€</strong><p id="enemiesKilled">0</p></div>
                <div class="stat-item"><strong>å…³å¡</strong><p id="finalLevel">1</p></div>
            </div>
            <p id="gameOverReason" style="color: #8892b0; margin-bottom: 15px;"></p>
            <button class="menu-btn" onclick="restartGame()">ğŸ”„ å†æ¥ä¸€å±€</button>
            <button class="menu-btn secondary" onclick="backToMenu()">ğŸ  èœå•</button>
        </div>
        
        <div class="version">v3.5</div>
    </div>

    <script>
        // ============ æ¸¸æˆé…ç½® ============
        const CANVAS_WIDTH = 600;
        const CANVAS_HEIGHT = 400;
        const TILE_SIZE = 40;
        const TANK_SIZE = 30;
        const BULLET_SIZE = 6;
        const PLAYER_SPEED = 3;
        const ENEMY_SPEED_BASE = 0.9; // é™ä½40% (åŸæ¥æ˜¯1.5)
        const BULLET_SPEED_BASE = 5;
        
        const Direction = { UP: 0, RIGHT: 1, DOWN: 2, LEFT: 3 };
        
        const CellType = {
            EMPTY: 0, BRICK: 1, GRASS: 2, STEEL: 3,
            PLAYER_SPAWN: 4, ENEMY_SPAWN: 5, BASE: 9
        };
        
        const PowerUpType = { STAR: 'star', LIFE: 'life', SHIELD: 'shield', BOMB: 'bomb' };
        
        const EnemyType = {
            NORMAL: { color: '#ff6b6b', hp: 1, speed: 1, score: 100 },
            FAST: { color: '#ffa502', hp: 1, speed: 1.8, score: 150 },
            HEAVY: { color: '#8e44ad', hp: 3, speed: 0.8, score: 300 },
            ELITE: { color: '#e74c3c', hp: 2, speed: 1.3, score: 250 }
        };
        
        const MAPS = [
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,4,0,0,2,2,0,0,2,2,0,0,0,5,1],[1,0,1,0,2,0,1,1,0,2,0,1,0,0,1],[1,0,1,0,0,0,0,0,0,0,0,1,0,0,1],[1,2,2,0,1,1,0,0,1,1,0,2,2,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,0,1,0,2,0,1,9,1,0,2,0,1,0,1],[1,0,1,0,2,0,1,3,1,0,2,0,1,0,1],[1,5,0,0,0,0,0,0,0,0,0,0,0,5,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,4,0,3,2,2,0,0,2,2,3,0,0,5,1],[1,0,3,0,2,0,3,3,0,2,0,3,0,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,2,2,0,1,1,0,0,1,1,0,2,2,0,1],[1,3,0,0,0,0,0,0,0,0,0,0,0,3,1],[1,0,1,0,2,0,1,9,1,0,2,0,1,0,1],[1,0,3,0,2,0,1,3,1,0,2,0,3,0,1],[1,5,0,0,0,0,0,0,0,0,0,0,0,5,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,4,0,0,0,0,0,0,0,0,0,0,0,5,1],[1,0,3,2,3,0,0,0,0,0,3,2,3,0,1],[1,0,2,0,0,0,1,1,1,0,0,0,2,0,1],[1,0,3,0,0,0,0,9,0,0,0,0,3,0,1],[1,0,2,0,0,0,1,3,1,0,0,0,2,0,1],[1,0,3,2,3,0,0,0,0,0,3,2,3,0,1],[1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],[1,5,0,0,0,0,0,0,0,0,0,0,0,5,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,4,0,0,0,0,0,5,0,0,0,0,0,5,1],[1,0,3,3,0,0,0,0,0,0,0,3,3,0,1],[1,0,3,2,2,0,0,0,0,0,2,2,3,0,1],[1,0,0,2,9,3,0,0,0,3,9,2,0,0,1],[1,0,0,0,3,3,0,0,0,3,3,0,0,0,1],[1,0,3,2,2,0,0,0,0,0,2,2,3,0,1],[1,0,3,3,0,0,0,0,0,0,0,3,3,0,1],[1,5,0,0,0,0,0,5,0,0,0,0,0,5,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]],
            [[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,4,3,0,0,0,0,0,0,0,0,0,0,3,1],[1,3,2,3,0,3,3,0,0,3,3,0,3,2,1],[1,0,3,0,0,0,0,0,0,0,0,0,0,3,1],[1,0,0,0,3,3,0,9,0,3,3,0,0,0,1],[1,0,3,0,3,3,0,3,0,3,3,0,3,0,1],[1,3,2,3,0,0,0,0,0,0,0,3,2,3,1],[1,0,3,0,0,0,0,0,0,0,0,0,3,0,1],[1,3,0,0,0,3,3,5,3,3,0,0,0,3,1],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]]
        ];
        
        // ============ æ¸¸æˆçŠ¶æ€ ============
        let canvas, ctx;
        let gameState = 'MENU';
        let map = [], powerUps = [];
        let score = 0, lives = 3, level = 1, baseHp = 3;
        let keys = {};
        let grassAlpha = 0.6;
        let highScore = 0;
        let mobileMode = false;
        let stats = { enemiesKilled: 0, maxCombo: 0, currentCombo: 0, comboTimer: 0 };
        let player = { x: 0, y: 0, dir: Direction.UP, color: '#4ecdc4', lastShot: 0, shotInterval: 300, powerLevel: 1, shieldTime: 0, inGrass: false };
        let enemies = [], bullets = [], explosions = [], floatingTexts = [];
        let basePos = { x: 0, y: 0 };
        
        // ============ åˆå§‹åŒ– ============
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;
            
            try { highScore = parseInt(localStorage.getItem('tankHighScore') || '0'); } catch(e) {}
            document.getElementById('highScoreDisplay').textContent = highScore;
            
            const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
            mobileMode = isTouchDevice || window.innerWidth <= 768;
            
            if(mobileMode) {
                document.getElementById('leftControl').classList.add('active');
                document.getElementById('rightControl').classList.add('active');
                document.getElementById('mobileBtn').textContent = 'ğŸ“± è§¦å±æ¨¡å¼: å¼€';
            }
            
            setupControls();
            setupKeyboard();
            window.addEventListener('resize', handleResize);
            handleResize();
            
            initMap();
            initPlayer();
            updateUI();
            gameLoop();
        }
        
        function handleResize() {
            const frame = document.getElementById('gameFrame');
            const availableWidth = frame.clientWidth;
            const availableHeight = frame.clientHeight;
            
            const scale = Math.min(
                availableWidth / CANVAS_WIDTH,
                availableHeight / CANVAS_HEIGHT
            ) * 0.98;
            
            canvas.style.width = Math.floor(CANVAS_WIDTH * scale) + 'px';
            canvas.style.height = Math.floor(CANVAS_HEIGHT * scale) + 'px';
        }
        
        // ============ æ‘‡æ†æ§åˆ¶ ============
        let joystickActive = false;
        let joystickCenter = { x: 0, y: 0 };
        let joystickRadius = 75; // åº•åº§åŠå¾„
        let joystickMaxDist = 45; // æ‘‡æ†å¤´æœ€å¤§åç§»è·ç¦»
        
        function setupControls() {
            const joystickBase = document.getElementById('joystickBase');
            const joystickKnob = document.getElementById('joystickKnob');
            const fireBtn = document.querySelector('.fire-btn');
            
            // æ‘‡æ†äº‹ä»¶
            const joystickStart = (e) => {
                e.preventDefault();
                joystickActive = true;
                joystickKnob.classList.add('active');
                updateJoystick(e);
            };
            
            const joystickMove = (e) => {
                if(!joystickActive) return;
                e.preventDefault();
                updateJoystick(e);
            };
            
            const joystickEnd = (e) => {
                if(!joystickActive) return;
                e.preventDefault();
                joystickActive = false;
                joystickKnob.classList.remove('active');
                // é‡ç½®æ‘‡æ†ä½ç½®
                joystickKnob.style.transform = 'translate(-50%, -50%)';
                // åœæ­¢ç§»åŠ¨
                keys['w'] = keys['s'] = keys['a'] = keys['d'] = false;
            };
            
            joystickBase.addEventListener('touchstart', joystickStart, { passive: false });
            joystickBase.addEventListener('touchmove', joystickMove, { passive: false });
            joystickBase.addEventListener('touchend', joystickEnd, { passive: false });
            joystickBase.addEventListener('touchcancel', joystickEnd, { passive: false });
            
            joystickBase.addEventListener('mousedown', joystickStart);
            document.addEventListener('mousemove', joystickMove);
            document.addEventListener('mouseup', joystickEnd);
            
            // å°„å‡»æŒ‰é’®
            if(fireBtn) {
                const startHandler = (e) => {
                    e.preventDefault();
                    keys['j'] = true;
                    fireBtn.classList.add('pressed');
                };
                const endHandler = (e) => {
                    e.preventDefault();
                    keys['j'] = false;
                    fireBtn.classList.remove('pressed');
                };
                
                fireBtn.addEventListener('touchstart', startHandler, { passive: false });
                fireBtn.addEventListener('touchend', endHandler, { passive: false });
                fireBtn.addEventListener('touchcancel', endHandler);
                fireBtn.addEventListener('mousedown', startHandler);
                fireBtn.addEventListener('mouseup', endHandler);
                fireBtn.addEventListener('mouseleave', () => { keys['j'] = false; fireBtn.classList.remove('pressed'); });
            }
        }
        
        function updateJoystick(e) {
            const joystickBase = document.getElementById('joystickBase');
            const joystickKnob = document.getElementById('joystickKnob');
            const rect = joystickBase.getBoundingClientRect();
            
            // è®¡ç®—ä¸­å¿ƒç‚¹
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            // è·å–è§¦æ‘¸/é¼ æ ‡ä½ç½®
            let clientX, clientY;
            if(e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else if(e.changedTouches && e.changedTouches.length > 0) {
                clientX = e.changedTouches[0].clientX;
                clientY = e.changedTouches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            // è®¡ç®—åç§»
            let dx = clientX - centerX;
            let dy = clientY - centerY;
            
            // è®¡ç®—è·ç¦»å’Œè§’åº¦
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);
            
            // é™åˆ¶æœ€å¤§è·ç¦»
            const limitedDist = Math.min(distance, joystickMaxDist);
            
            // è®¡ç®—æ‘‡æ†å¤´ä½ç½®
            const knobX = Math.cos(angle) * limitedDist;
            const knobY = Math.sin(angle) * limitedDist;
            
            // æ›´æ–°æ‘‡æ†å¤´ä½ç½®
            joystickKnob.style.transform = `translate(calc(-50% + ${knobX}px), calc(-50% + ${knobY}px))`;
            
            // è®¾ç½®æ–¹å‘é”®ï¼ˆæ ¹æ®è§’åº¦ï¼‰
            const threshold = 0.3; // ç§»åŠ¨é˜ˆå€¼
            keys['w'] = keys['s'] = keys['a'] = keys['d'] = false;
            
            if(distance > 10) { // æœ€å°è§¦å‘è·ç¦»
                // ä¸Š/ä¸‹
                if(dy < -threshold * limitedDist) keys['w'] = true;
                else if(dy > threshold * limitedDist) keys['s'] = true;
                
                // å·¦/å³
                if(dx < -threshold * limitedDist) keys['a'] = true;
                else if(dx > threshold * limitedDist) keys['d'] = true;
            }
        }
        
        function setupKeyboard() {
            document.addEventListener('keydown', (e) => {
                const key = e.key.toLowerCase();
                keys[key] = true;
                if(key === 'p') {
                    if(gameState === 'PLAYING') pauseGame();
                    else if(gameState === 'PAUSED') resumeGame();
                }
                if(['arrowup','arrowdown','arrowleft','arrowright',' '].includes(key)) e.preventDefault();
            });
            document.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });
        }
        
        // ============ æ¸¸æˆé€»è¾‘ ============
        function initMap() {
            const mapIndex = Math.min(level - 1, MAPS.length - 1);
            map = JSON.parse(JSON.stringify(MAPS[mapIndex]));
            for(let row = 0; row < map.length; row++) {
                for(let col = 0; col < map[row].length; col++) {
                    if(map[row][col] === CellType.BASE) {
                        basePos = { x: col * TILE_SIZE, y: row * TILE_SIZE };
                    }
                }
            }
        }
        
        function initPlayer() {
            for(let row = 0; row < map.length; row++) {
                for(let col = 0; col < map[row].length; col++) {
                    if(map[row][col] === CellType.PLAYER_SPAWN) {
                        player.x = col * TILE_SIZE + (TILE_SIZE - TANK_SIZE) / 2;
                        player.y = row * TILE_SIZE + (TILE_SIZE - TANK_SIZE) / 2;
                        player.dir = Direction.UP;
                        player.shieldTime = 2000;
                    }
                }
            }
        }
        
        function startGame() {
            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('legendBox').classList.add('hidden');
            document.getElementById('pauseBtn').classList.add('active');
            gameState = 'PLAYING';
            resetGame();
        }
        
        function resetGame() {
            score = 0; lives = 3; level = 1; baseHp = 3;
            stats = { enemiesKilled: 0, maxCombo: 0, currentCombo: 0, comboTimer: 0 };
            player.powerLevel = 1;
            enemies = []; bullets = []; explosions = []; powerUps = []; floatingTexts = [];
            initMap();
            initPlayer();
            updateUI();
            setTimeout(() => spawnEnemy(), 500);
            setTimeout(() => spawnEnemy(), 1500);
        }
        
        function pauseGame() {
            if(gameState === 'PLAYING') {
                gameState = 'PAUSED';
                document.getElementById('pauseMenu').classList.remove('hidden');
            }
        }
        
        function resumeGame() {
            gameState = 'PLAYING';
            document.getElementById('pauseMenu').classList.add('hidden');
        }
        
        function backToMenu() {
            gameState = 'MENU';
            document.getElementById('pauseMenu').classList.add('hidden');
            document.getElementById('gameOver').classList.add('hidden');
            document.getElementById('mainMenu').classList.remove('hidden');
            document.getElementById('legendBox').classList.remove('hidden');
            document.getElementById('pauseBtn').classList.remove('active');
            document.getElementById('highScoreDisplay').textContent = highScore;
        }
        
        function toggleMobileMode() {
            mobileMode = !mobileMode;
            const leftControl = document.getElementById('leftControl');
            const rightControl = document.getElementById('rightControl');
            const btn = document.getElementById('mobileBtn');
            
            if(mobileMode) {
                leftControl.classList.add('active');
                rightControl.classList.add('active');
                btn.textContent = 'ğŸ“± è§¦å±æ¨¡å¼: å¼€';
            } else {
                leftControl.classList.remove('active');
                rightControl.classList.remove('active');
                btn.textContent = 'ğŸ“± è§¦å±æ¨¡å¼: å…³';
            }
        }
        
        function spawnEnemy() {
            if(gameState !== 'PLAYING') return;
            const spawnPoints = [];
            for(let row = 0; row < map.length; row++) {
                for(let col = 0; col < map[row].length; col++) {
                    if(map[row][col] === CellType.ENEMY_SPAWN) {
                        spawnPoints.push({
                            x: col * TILE_SIZE + (TILE_SIZE - TANK_SIZE) / 2,
                            y: row * TILE_SIZE + (TILE_SIZE - TANK_SIZE) / 2
                        });
                    }
                }
            }
            
            const maxEnemies = 3 + Math.min(level, 5);
            if(spawnPoints.length > 0 && enemies.length < maxEnemies) {
                const spawn = spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
                let canSpawn = true;
                for(let e of enemies) {
                    if(Math.abs(e.x - spawn.x) < TANK_SIZE && Math.abs(e.y - spawn.y) < TANK_SIZE) canSpawn = false;
                }
                
                if(canSpawn) {
                    let enemyType = EnemyType.NORMAL;
                    const rand = Math.random();
                    if(level >= 5 && rand < 0.15) enemyType = EnemyType.ELITE;
                    else if(level >= 4 && rand < 0.3) enemyType = EnemyType.HEAVY;
                    else if(level >= 2 && rand < 0.4) enemyType = EnemyType.FAST;
                    
                    enemies.push({
                        x: spawn.x, y: spawn.y, dir: Direction.DOWN, type: enemyType,
                        color: enemyType.color, hp: enemyType.hp, maxHp: enemyType.hp,
                        speed: enemyType.speed * ENEMY_SPEED_BASE * (1 + level * 0.05), score: enemyType.score,
                        lastShot: 0, shotInterval: 1500 - level * 100, lastMove: 0, moveInterval: 1000
                    });
                }
            }
        }
        
        function spawnPowerUp() {
            if(Math.random() > 0.25 || powerUps.length >= 2) return;
            const emptySpots = [];
            for(let row = 1; row < map.length - 1; row++) {
                for(let col = 1; col < map[row].length - 1; col++) {
                    if(map[row][col] === CellType.EMPTY) emptySpots.push({ x: col * TILE_SIZE, y: row * TILE_SIZE });
                }
            }
            if(emptySpots.length === 0) return;
            const spot = emptySpots[Math.floor(Math.random() * emptySpots.length)];
            const types = [PowerUpType.STAR, PowerUpType.LIFE, PowerUpType.SHIELD, PowerUpType.BOMB];
            powerUps.push({ x: spot.x + TILE_SIZE/2 - 15, y: spot.y + TILE_SIZE/2 - 15, type: types[Math.floor(Math.random() * types.length)], spawnTime: Date.now() });
        }
        
        function collectPowerUp(p) {
            switch(p.type) {
                case PowerUpType.STAR: player.powerLevel = Math.min(player.powerLevel + 1, 3); score += 50; showFloatingText(player.x, player.y - 20, 'ç«åŠ›+' + player.powerLevel, '#ffd700'); break;
                case PowerUpType.LIFE: lives = Math.min(lives + 1, 5); showFloatingText(player.x, player.y - 20, 'ç”Ÿå‘½+1', '#ff6b6b'); break;
                case PowerUpType.SHIELD: player.shieldTime = 5000; showFloatingText(player.x, player.y - 20, 'æŠ¤ç›¾!', '#4ecdc4'); break;
                case PowerUpType.BOMB: enemies.forEach(e => { createExplosion(e.x + TANK_SIZE/2, e.y + TANK_SIZE/2, e.color, 15); score += 100; stats.enemiesKilled++; }); enemies = []; showFloatingText(player.x, player.y - 20, 'BOOM!', '#ff4757'); break;
            }
            updateUI();
        }
        
        function showFloatingText(x, y, text, color) { floatingTexts.push({ x, y, text, color, life: 1, vy: -1.5 }); }
        
        function checkRectCollision(r1, r2) { return r1.x < r2.x + r2.width && r1.x + r1.width > r2.x && r1.y < r2.y + r2.height && r1.y + r1.height > r2.y; }
        
        function checkWallCollision(x, y) {
            const tankRect = { x, y, width: TANK_SIZE, height: TANK_SIZE };
            for(let row = 0; row < map.length; row++) {
                for(let col = 0; col < map[row].length; col++) {
                    const cell = map[row][col];
                    if(cell === CellType.BRICK || cell === CellType.STEEL) {
                        if(checkRectCollision(tankRect, { x: col * TILE_SIZE, y: row * TILE_SIZE, width: TILE_SIZE, height: TILE_SIZE })) return true;
                    }
                }
            }
            return false;
        }
        
        function checkInGrass(x, y) {
            const col = Math.floor((x + TANK_SIZE/2) / TILE_SIZE);
            const row = Math.floor((y + TANK_SIZE/2) / TILE_SIZE);
            return row >= 0 && row < map.length && col >= 0 && col < map[0].length && map[row][col] === CellType.GRASS;
        }
        
        function shoot(tank, isPlayer) {
            const now = Date.now();
            if(now - tank.lastShot < tank.shotInterval) return;
            tank.lastShot = now;
            let bx = tank.x + TANK_SIZE/2 - BULLET_SIZE/2;
            let by = tank.y + TANK_SIZE/2 - BULLET_SIZE/2;
            switch(tank.dir) {
                case Direction.UP: by -= TANK_SIZE/2; break;
                case Direction.DOWN: by += TANK_SIZE/2; break;
                case Direction.LEFT: bx -= TANK_SIZE/2; break;
                case Direction.RIGHT: bx += TANK_SIZE/2; break;
            }
            const bulletCount = isPlayer ? Math.min(tank.powerLevel, 2) : 1;
            for(let i = 0; i < bulletCount; i++) {
                let offsetX = 0, offsetY = 0;
                if(bulletCount === 2) {
                    if(tank.dir === Direction.UP || tank.dir === Direction.DOWN) offsetX = (i === 0 ? -8 : 8);
                    else offsetY = (i === 0 ? -8 : 8);
                }
                bullets.push({ x: bx + offsetX, y: by + offsetY, dir: tank.dir, isPlayer, color: isPlayer ? '#ffd700' : '#ff4757', power: isPlayer ? tank.powerLevel : 1 });
            }
        }
        
        function updatePlayer() {
            if(gameState !== 'PLAYING') return;
            let newX = player.x, newY = player.y, moved = false;
            if(keys['w'] || keys['arrowup']) { newY -= PLAYER_SPEED; player.dir = Direction.UP; moved = true; }
            else if(keys['s'] || keys['arrowdown']) { newY += PLAYER_SPEED; player.dir = Direction.DOWN; moved = true; }
            else if(keys['a'] || keys['arrowleft']) { newX -= PLAYER_SPEED; player.dir = Direction.LEFT; moved = true; }
            else if(keys['d'] || keys['arrowright']) { newX += PLAYER_SPEED; player.dir = Direction.RIGHT; moved = true; }
            
            if(moved) {
                newX = Math.max(0, Math.min(CANVAS_WIDTH - TANK_SIZE, newX));
                newY = Math.max(0, Math.min(CANVAS_HEIGHT - TANK_SIZE, newY));
                if(!checkWallCollision(newX, newY)) { player.x = newX; player.y = newY; }
            }
            player.inGrass = checkInGrass(player.x, player.y);
            if(player.shieldTime > 0) player.shieldTime -= 16;
            if(keys['j'] || keys[' ']) shoot(player, true);
            
            for(let i = powerUps.length - 1; i >= 0; i--) {
                if(checkRectCollision({ x: player.x, y: player.y, width: TANK_SIZE, height: TANK_SIZE }, { x: powerUps[i].x, y: powerUps[i].y, width: 30, height: 30 })) {
                    collectPowerUp(powerUps[i]);
                    powerUps.splice(i, 1);
                }
            }
        }
        
        function updateEnemies() {
            if(gameState !== 'PLAYING') return;
            const now = Date.now();
            enemies.forEach(enemy => {
                if(now - enemy.lastMove > enemy.moveInterval) {
                    const dx = player.x - enemy.x, dy = player.y - enemy.y;
                    if(Math.random() < 0.6) enemy.dir = (Math.abs(dx) > Math.abs(dy)) ? (dx > 0 ? Direction.RIGHT : Direction.LEFT) : (dy > 0 ? Direction.DOWN : Direction.UP);
                    else enemy.dir = Math.floor(Math.random() * 4);
                    enemy.lastMove = now;
                }
                let newX = enemy.x, newY = enemy.y;
                switch(enemy.dir) {
                    case Direction.UP: newY -= enemy.speed; break; case Direction.DOWN: newY += enemy.speed; break;
                    case Direction.LEFT: newX -= enemy.speed; break; case Direction.RIGHT: newX += enemy.speed; break;
                }
                newX = Math.max(0, Math.min(CANVAS_WIDTH - TANK_SIZE, newX));
                newY = Math.max(0, Math.min(CANVAS_HEIGHT - TANK_SIZE, newY));
                if(!checkWallCollision(newX, newY)) { enemy.x = newX; enemy.y = newY; }
                else enemy.dir = Math.floor(Math.random() * 4);
                if(Math.random() < 0.03) shoot(enemy, false);
            });
        }
        
        function updateBullets() {
            bullets = bullets.filter(bullet => {
                switch(bullet.dir) {
                    case Direction.UP: bullet.y -= BULLET_SPEED_BASE * (1 + level * 0.1); break; case Direction.DOWN: bullet.y += BULLET_SPEED_BASE * (1 + level * 0.1); break;
                    case Direction.LEFT: bullet.x -= BULLET_SPEED_BASE * (1 + level * 0.1); break; case Direction.RIGHT: bullet.x += BULLET_SPEED_BASE * (1 + level * 0.1); break;
                }
                if(bullet.x < 0 || bullet.x > CANVAS_WIDTH || bullet.y < 0 || bullet.y > CANVAS_HEIGHT) return false;
                const bulletRect = { x: bullet.x, y: bullet.y, width: BULLET_SIZE, height: BULLET_SIZE };
                
                for(let row = 0; row < map.length; row++) {
                    for(let col = 0; col < map[row].length; col++) {
                        const cell = map[row][col];
                        if(cell === CellType.BRICK || cell === CellType.STEEL || cell === CellType.BASE) {
                            if(checkRectCollision(bulletRect, { x: col * TILE_SIZE, y: row * TILE_SIZE, width: TILE_SIZE, height: TILE_SIZE })) {
                                createExplosion(bullet.x, bullet.y, '#888', 5);
                                if(cell === CellType.BRICK) { map[row][col] = CellType.EMPTY; score += 10; }
                                if(cell === CellType.BASE) { baseHp--; createExplosion(col * TILE_SIZE + TILE_SIZE/2, row * TILE_SIZE + TILE_SIZE/2, '#ff6b6b', 20); updateUI(); if(baseHp <= 0) gameOver(false, 'åŸºåœ°è¢«æ‘§æ¯ï¼'); }
                                updateUI(); return false;
                            }
                        }
                    }
                }
                
                if(bullet.isPlayer) {
                    for(let i = enemies.length - 1; i >= 0; i--) {
                        if(checkRectCollision(bulletRect, { x: enemies[i].x, y: enemies[i].y, width: TANK_SIZE, height: TANK_SIZE })) {
                            createExplosion(enemies[i].x + TANK_SIZE/2, enemies[i].y + TANK_SIZE/2, enemies[i].color, 10);
                            enemies[i].hp--;
                            if(enemies[i].hp <= 0) {
                                enemies.splice(i, 1);
                                stats.currentCombo++; stats.comboTimer = 2000;
                                if(stats.currentCombo > stats.maxCombo) stats.maxCombo = stats.currentCombo;
                                const comboBonus = Math.min(stats.currentCombo * 10, 100);
                                score += enemies[i]?.score + comboBonus || 100 + comboBonus;
                                if(stats.currentCombo >= 3) showFloatingText(enemies[i]?.x || 0, (enemies[i]?.y || 0) - 30, `${stats.currentCombo}è¿å‡»!`, '#ff6b6b');
                                stats.enemiesKilled++;
                                if(Math.random() < 0.2) spawnPowerUp();
                            }
                            updateUI(); return false;
                        }
                    }
                } else {
                    if(checkRectCollision(bulletRect, { x: player.x, y: player.y, width: TANK_SIZE, height: TANK_SIZE })) {
                        if(player.shieldTime <= 0) {
                            createExplosion(player.x + TANK_SIZE/2, player.y + TANK_SIZE/2, player.color, 15);
                            lives--; stats.currentCombo = 0; updateUI();
                            if(lives <= 0) gameOver(false, 'ç”Ÿå‘½è€—å°½ï¼');
                            else initPlayer();
                        } else createExplosion(bullet.x, bullet.y, '#4ecdc4', 5);
                        return false;
                    }
                }
                return true;
            });
        }
        
        function createExplosion(x, y, color, count) { for(let i = 0; i < count; i++) explosions.push({ x, y, vx: (Math.random() - 0.5) * 12, vy: (Math.random() - 0.5) * 12, life: 1, color, size: 3 + Math.random() * 4 }); }
        
        function updateExplosions() { explosions = explosions.filter(p => { p.x += p.vx; p.y += p.vy; p.life -= 0.04; return p.life > 0; }); }
        
        function drawTank(tank, isPlayer) {
            ctx.save();
            ctx.translate(tank.x + TANK_SIZE/2, tank.y + TANK_SIZE/2);
            if(tank.inGrass) ctx.globalAlpha = 0.5;
            if(isPlayer && player.shieldTime > 0) { ctx.beginPath(); ctx.arc(0, 0, TANK_SIZE/2 + 6, 0, Math.PI * 2); ctx.strokeStyle = `rgba(78, 205, 196, ${0.5 + Math.sin(Date.now() / 100) * 0.3})`; ctx.lineWidth = 3; ctx.stroke(); }
            let angle = 0;
            switch(tank.dir) { case Direction.UP: angle = -Math.PI/2; break; case Direction.RIGHT: angle = 0; break; case Direction.DOWN: angle = Math.PI/2; break; case Direction.LEFT: angle = Math.PI; break; }
            ctx.rotate(angle);
            ctx.fillStyle = tank.color;
            ctx.fillRect(-TANK_SIZE/2, -TANK_SIZE/2, TANK_SIZE, TANK_SIZE);
            if(!isPlayer && tank.maxHp > 1) { ctx.restore(); ctx.save(); const hpPercent = tank.hp / tank.maxHp; ctx.fillStyle = '#333'; ctx.fillRect(tank.x, tank.y - 8, TANK_SIZE, 4); ctx.fillStyle = hpPercent > 0.5 ? '#2ecc71' : '#e74c3c'; ctx.fillRect(tank.x, tank.y - 8, TANK_SIZE * hpPercent, 4); ctx.restore(); ctx.save(); ctx.translate(tank.x + TANK_SIZE/2, tank.y + TANK_SIZE/2); ctx.rotate(angle); }
            ctx.fillStyle = '#333';
            ctx.fillRect(-TANK_SIZE/2 - 2, -TANK_SIZE/2 + 2, 4, TANK_SIZE - 4);
            ctx.fillRect(TANK_SIZE/2 - 2, -TANK_SIZE/2 + 2, 4, TANK_SIZE - 4);
            ctx.beginPath(); ctx.arc(0, 0, TANK_SIZE/3, 0, Math.PI * 2); ctx.fill();
            if(isPlayer && tank.powerLevel > 1) { ctx.fillStyle = '#ffd700'; ctx.font = 'bold 11px Arial'; ctx.textAlign = 'center'; ctx.fillText('â˜…'.repeat(tank.powerLevel - 1), 0, 4); }
            ctx.fillStyle = '#444'; ctx.fillRect(0, -3, TANK_SIZE/2 + 10, 6);
            ctx.restore();
        }
        
        function drawMap() {
            for(let row = 0; row < map.length; row++) {
                for(let col = 0; col < map[row].length; col++) {
                    const cell = map[row][col], x = col * TILE_SIZE, y = row * TILE_SIZE;
                    switch(cell) {
                        case CellType.BRICK: ctx.fillStyle = '#8b4513'; ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE); ctx.fillStyle = '#a0522d'; ctx.fillRect(x + 3, y + 3, TILE_SIZE - 6, TILE_SIZE - 6); break;
                        case CellType.STEEL: ctx.fillStyle = '#4682b4'; ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE); ctx.fillStyle = '#5f9ea0'; ctx.fillRect(x + 2, y + 2, TILE_SIZE - 4, TILE_SIZE - 4); break;
                        case CellType.GRASS: ctx.fillStyle = `rgba(34, 139, 34, ${grassAlpha})`; ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE); break;
                        case CellType.BASE: ctx.fillStyle = '#8b4513'; ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE); ctx.fillStyle = '#deb887'; ctx.fillRect(x + 4, y + 4, TILE_SIZE - 8, TILE_SIZE - 8); ctx.fillStyle = '#ff6b6b'; ctx.beginPath(); ctx.moveTo(x + TILE_SIZE/2, y + 6); ctx.lineTo(x + 6, y + TILE_SIZE/2); ctx.lineTo(x + TILE_SIZE - 6, y + TILE_SIZE/2); ctx.closePath(); ctx.fill(); ctx.fillRect(x + 10, y + TILE_SIZE/2, TILE_SIZE - 20, TILE_SIZE/2 - 8); break;
                    }
                }
            }
        }
        
        function drawPowerUps() {
            const now = Date.now();
            powerUps.forEach((p, index) => {
                if(now - p.spawnTime > 10000) { powerUps.splice(index, 1); return; }
                const icons = { star: 'â­', life: 'â¤ï¸', shield: 'ğŸ›¡ï¸', bomb: 'ğŸ’£' };
                ctx.font = '22px Arial'; ctx.textAlign = 'center'; ctx.fillText(icons[p.type], p.x + 15, p.y + 24);
            });
        }
        
        function draw() {
            ctx.fillStyle = '#0a0a0a'; ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            drawMap();
            grassAlpha = 0.4 + Math.sin(Date.now() / 400) * 0.15;
            drawPowerUps();
            enemies.forEach(e => drawTank(e));
            drawTank(player, true);
            bullets.forEach(b => { ctx.fillStyle = b.color; ctx.beginPath(); ctx.arc(b.x + BULLET_SIZE/2, b.y + BULLET_SIZE/2, BULLET_SIZE/2, 0, Math.PI * 2); ctx.fill(); });
            explosions.forEach(p => { ctx.fillStyle = p.color; ctx.globalAlpha = p.life; ctx.beginPath(); ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2); ctx.fill(); });
            ctx.globalAlpha = 1;
            floatingTexts = floatingTexts.filter(t => { t.y += t.vy; t.life -= 0.02; if(t.life > 0) { ctx.fillStyle = t.color; ctx.globalAlpha = t.life; ctx.font = 'bold 14px Arial'; ctx.textAlign = 'center'; ctx.fillText(t.text, t.x, t.y); ctx.globalAlpha = 1; return true; } return false; });
        }
        
        function updateUI() { document.getElementById('scoreVal').textContent = score; document.getElementById('livesVal').textContent = lives; document.getElementById('baseVal').textContent = baseHp; }
        
        function gameOver(won, reason) {
            gameState = 'GAMEOVER';
            if(score > highScore) { highScore = score; try { localStorage.setItem('tankHighScore', highScore); } catch(e) {} }
            const panel = document.getElementById('gameOver');
            panel.className = 'game-over-panel ' + (won ? 'win' : 'lose');
            panel.classList.remove('hidden');
            document.getElementById('gameOverTitle').textContent = won ? 'ğŸ‰ VICTORY!' : 'ğŸ’€ GAME OVER';
            document.getElementById('gameOverReason').textContent = reason;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('maxCombo').textContent = stats.maxCombo;
            document.getElementById('enemiesKilled').textContent = stats.enemiesKilled;
            document.getElementById('finalLevel').textContent = level;
        }
        
        function restartGame() { document.getElementById('gameOver').classList.add('hidden'); gameState = 'PLAYING'; resetGame(); }
        
        function gameLoop() {
            if(gameState === 'PLAYING') {
                updatePlayer(); updateEnemies(); updateBullets(); updateExplosions();
                if(stats.currentCombo > 0) { stats.comboTimer -= 16; if(stats.comboTimer <= 0) { stats.currentCombo = 0; updateUI(); } }
                if(Math.random() < 0.015 + level * 0.002) spawnEnemy();
                if(Math.random() < 0.005) spawnPowerUp();
                if(score >= level * 800 && enemies.length === 0 && level < MAPS.length) { level++; showFloatingText(CANVAS_WIDTH/2, CANVAS_HEIGHT/2, `ç¬¬ ${level} å…³!`, '#ffd700'); initMap(); initPlayer(); enemies = []; bullets = []; }
                else if(level >= MAPS.length && score >= MAPS.length * 800 && enemies.length === 0) gameOver(true, 'æ­å–œé€šå…³æ‰€æœ‰å…³å¡ï¼');
            }
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        window.onload = init;
    </script>
</body>
</html>
